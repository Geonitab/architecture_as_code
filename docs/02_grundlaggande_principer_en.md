# Fundamental principles for Architecture as Code Architecture as Code builds on fundamental principles that ensures successsrik implementation of kodifierad system architecture. These principles encompasses the entire system landscape and skapar en helhetssyn for arkitekturhantering. ![fundamental principles diagram](images/diagram_02_kapitel1.png) Diagrammet visar det naturliga flödet from deklarativ code through versionskontroll and automation to reproducerbarhet and skalbarhet - de fem grundpelarna within Architecture as Code. ## Deklarativ arkitekturdefinition Den deklarativa approachen within Architecture as Code innebär to describe önskat systemtostånd on all nivåer - from application components to infrastructure. This skiljer sig from imperativ programmering where varje steg must specificeras explicit. Deklarativ definition enables to describe arkitekturens önskade tostånd, vilket Architecture as Code utvidgar to omfatta application architecture, API-kontrakt and organizational structures. ## Helhetsperspektiv on kodifiering Architecture as Code encompasses the entire systemecosystemet through en holistisk approach. This includes application logic, data flows, security policies, compliance rules and organizations'trukturer. Ett praktiskt exempel is how en change in en applikations API automatically can propagera throughout the entire architecture - from säkerhetskonfigurationer to dokumentation - all afterthat det is defined as code. ## Immutable architecture patterns Principen om immutable arkitektur innebär to the entire system architecture is managed through oforänderliga komponenter. Istället for to modifiera befintliga delar skapas nya versioner that ersätter gamla on all nivåer. This skapar forutsägbarhet and eliminerar architectural drift - where system gradvis divergerar from sin ofsedda design over tid. ## Testbarhet on arkitekturnivå Architecture as Code enables testing of the entire system architecture, not only enskilda komponenter. This includes validering of architecture patterns, compliance with designprinciples and verifiering of end-to-end-flöden. Arkitekturtester validerar designbeslut, systemkomplexitet and ensures to the entire architecture fungerar that ofsett. ## Documentation as Code Documentation as Code (DaC) representerar principen to treat dokumentation that en integrerad del of kodbasen rather än that ett separat artefakt. This innebär to dokumentation lagras tosammans with koden, version controlled with samma tools and duringgo samma kvalitetssäkringsprocesses that applikationskoden. ### Fördelar with Documentation as Code **Versionskontroll and historik**: through to lagra dokumentation in Git or andra versionskontrollsystem får organizations automatisk sonrbarhet of changes, möjlighet to återställa tidigare versioner and full historik over dokumentationens utveckling. **Kollaboration and granskning**: Pull requests and merge-processes ensures to dokumentationsändringar granskas before de publiceras. This improver kvaliteten and minskar risken for felaktig or foråldrad information. **CI/CD-integration**: automated pipelines can generera, validera and publicera dokumentation automatically när code forändras. This eliminerar manual steg and ensures to dokumentationen allid is uppdaterad. ### Praktisk implementation ```yaml # .github/workflows/docs.yml name: Documentation Build and Deploy on: push: paths: ['docs/**', 'README.md'] pull_request: paths: ['docs/**'] jobs: build-docs: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - name: Setup Node.js uses: actions/setup-node@v4 with: node-version: '18' - name: Install dependencies run: npm install - name: Generate documentation run: | npm run docs:build npm run docs:lint - name: Deploy to GitHub Pages if: github.ref == 'refs/heads/main' uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./docs/dist ``` Moderna tools that GitBook, Gitiles and MkDocs enables automatisk generering of webbdokumentation from Markdown-filer lagrade tosammans with koden. ## Requirements as Code Requirements as Code (RaC) transformerar traditional krofspecifiction from textdokument to machine-readable code that can exekveras, valideras and is automated. This paradigmskifte enables kontinuerlig verifiering of to systemet uppfyller their requirements throughout the entire utvecklingslivscykeln. ### Automation and traceability **Automatiserad validering**: requirements uttryckta as code can exekveras automatically mot systemet for to verifiera compliance. This eliminerar manuell testing and ensures konsekvent validering. **Direkt koppling between requirements and code**: Varje systemkomponent can kopplas tobaka to specific requirements, vilket skapar complete traceability from affärsbehov to teknisk implementation. **Continuous compliance**: changes in systemet valideras automatically mot all definierade requirements, vilket forhindrar regression and ensures ongoing compliance. ### Praktiskt exempel with Open Policy Agent (OPA) ```yaml # Requirements/security-requirements.yaml apiVersion: policy/v1 kind: RequirementSet metadata: name: Swedish-sakerhetskrof version: "1.2" spec: requirements: - id: SEC-001 type: security description: "all S3 buckets must ha kryptering aktiverad" priority: critical compliance: ["GDPR", "ISO27001"] policy: | package security.s3_encryption deny[msg] { input.resource_type == "aws_s3_bucket" not input.server_side_encryption_configuration msg := "S3 bucket must ha server-side encryption" } - id: GDPR-001 type: compliance description: "Persondata must lagras within EU/EES" priority: critical compliance: ["GDPR"] policy: | package compliance.data_residency deny[msg] { input.resource_type == "aws_rds_instance" not contains(input.ofailability_zone, "eu-") msg := "RDS instans must placeras in EU-region" } ``` ### Validering and test-automation Requirements as Code integreras naturligt with test-automation through to requirements blir executable specifications: ```python # Test/requirements_validation.py import yaml import opa class RequirementsValidator: def __init__(self, requirements_file: str): with open(requirements_file, 'r') as f: self.requirements = yaml.safe_load(f) def validate_requirement(self, req_id: str, system_config: dict): requirement = self.find_requirement(req_id) policy_result = opa.evaluate( requirement['policy'], system_config ) return { 'requirement_id': req_id, 'status': 'passed' if not policy_result else 'failed', 'violations': policy_result } def validate_all_requirements(self) -> dict: results = [] for req in self.requirements['spec']['requirements']: result = self.validate_requirement(req['id'], self.system_config) results.append(result) return { 'total_requirements': len(self.requirements['spec']['requirements']), 'passed': len([r for r in results if r['status'] == 'passed']), 'failed': len([r for r in results if r['status'] == 'failed']), 'details': results } ``` Swedish organizations drar särskild nytta of Requirements as Code for to automatically validera GDPR-compliance, finansiella regulations and myndighetskrof that konstant must uppfyllas. Sources: - Red Hat. "Architecture as Code Principles and Best Practices." Red Hat Developer. - Martin, R. "Clean Architecture: A Craftsman's Guide to Software Structure." Prentice Hall, 2017. - ThoughtWorks. "Architecture as Code: The Next Evolution." Technology Radar, 2024. - GitLab. "Documentation as Code: Best Practices and implementation." GitLab Documentation, 2024. - Open Policy Agent. "Policy as Code: Expressing Requirements as Code." CNCF OPA Project, 2024. - Atlassian. "Documentation as Code: Treating Docs as a First-Class Citizen." Atlassian Developer, 2023. - NIST. "Requirements Engineering for Secure Systems." NIST Special Publication 800-160, 2023.