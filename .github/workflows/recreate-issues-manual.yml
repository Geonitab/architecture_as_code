name: Recreate open issues (title+body only, closes originals, 3-minute delay, supports "All")

on:
  workflow_dispatch:
    inputs:
      issue_numbers:
        description: 'Comma-separated list of OPEN issue numbers to recreate, or "All" to recreate all open issues (blank = All)'
        required: false
        type: string
        default: All

permissions:
  issues: write
  contents: read

jobs:
  recreate:
    runs-on: ubuntu-latest
    steps:
      - name: Close originals and recreate issues
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const rawInput = (core.getInput('issue_numbers') || '').trim();

            // Helper: extract numeric issue refs from any messy string (e.g. "#12, issue 34; 56")
            const extractNumbers = (s) => {
              return (s.match(/\d+/g) || []).map(n => parseInt(n, 10)).filter(Boolean);
            };

            let issueNumbers = [];

            if (rawInput === '' || rawInput.toLowerCase() === 'all') {
              core.info('Fetching all open issues (excluding pull requests)...');
              let page = 1;
              while (true) {
                const { data: issues } = await github.rest.issues.listForRepo({
                  owner,
                  repo,
                  state: 'open',
                  per_page: 100,
                  page
                });
                if (issues.length === 0) break;

                // Filter out PRs (they have the pull_request field)
                issueNumbers.push(
                  ...issues.filter(i => !i.pull_request).map(i => i.number)
                );
                page++;
              }
              core.info(`Found ${issueNumbers.length} open issues (excluding PRs).`);
            } else {
              // Be lenient with input formatting
              issueNumbers = extractNumbers(rawInput);
            }

            // De-duplicate and sort to get a stable order
            issueNumbers = Array.from(new Set(issueNumbers)).sort((a, b) => a - b);

            if (issueNumbers.length === 0) {
              core.setFailed('No valid open issue numbers found.');
              return;
            }

            core.notice(`Will process issues: ${issueNumbers.join(', ')}`);

            for (let i = 0; i < issueNumbers.length; i++) {
              const issue_number = issueNumbers[i];
              core.info(`Processing issue #${issue_number}...`);

              try {
                const { data: original } = await github.rest.issues.get({
                  owner,
                  repo,
                  issue_number
                });

                // Skip pull requests
                if (original.pull_request) {
                  core.warning(`Item #${issue_number} is a pull request. Skipping.`);
                  continue;
                }

                if (original.state !== 'open') {
                  core.warning(`Issue #${issue_number} is not open. Skipping.`);
                  continue;
                }

                const title = original.title || 'Untitled';
                let body = original.body || '';

                // Remove obvious self-references like "#<old-number>" to avoid accidental backlinks
                const issueRefPattern = new RegExp(`(^|[^\\w/])#${issue_number}(?!\\w)`, 'g');
                body = body.replace(issueRefPattern, '$1');

                // 1) Close the original issue silently
                await github.rest.issues.update({
                  owner,
                  repo,
                  issue_number,
                  state: 'closed',
                  state_reason: 'completed' // or 'not_planned' if preferred
                });
                core.info(`Closed original issue #${issue_number}.`);

                // 2) Create the new clean issue (title + body only)
                const { data: newIssue } = await github.rest.issues.create({
                  owner,
                  repo,
                  title,
                  body
                });
                core.info(`✅ Created new issue #${newIssue.number} from original #${issue_number}.`);

                // 3) Wait 3 minutes before processing the next issue
                if (i < issueNumbers.length - 1) {
                  core.info('⏳ Waiting 3 minutes before next issue...');
                  await new Promise(resolve => setTimeout(resolve, 3 * 60 * 1000));
                }
              } catch (err) {
                core.warning(`Failed to process issue #${issue_number}: ${err.message}`);
              }
            }

            core.info('🎉 All requested issues processed.');