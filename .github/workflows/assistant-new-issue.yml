name: "Assistant - New Issue"

on:
  issues:
    types: [opened, edited, reopened]

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  propose-changes:
    name: Propose patch for issue
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Gather context
        id: ctx
        run: |
          set -eu
          echo "Issue title: ${{ github.event.issue.title }}"
          printf "Issue body length: %s\n" "$(printf %s "${{ github.event.issue.body }}" | wc -c)"

      - name: Validate secrets
        id: validate
        run: |
          set -eu
          if [ -z "${{ secrets.OPENAI_API_KEY }}" ]; then
            echo "Error: Missing required secret OPENAI_API_KEY."
            echo "Add it in Settings -> Secrets and variables -> Actions."
            exit 1
          fi
          echo "Secrets validation passed."

      - name: Prepare context
        id: context
        run: |
          set -eu
          git ls-files > files.txt
          {
            printf '<<FILE_LIST>>\n'
            sed -e 's/^/ - /' files.txt
          } > prompt_context.txt
          echo "Prepared repository file list for model context."

      - name: Call OpenAI to propose a patch
        id: openai
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          OPENAI_BASE_URL: ${{ vars.OPENAI_BASE_URL || 'https://api.openai.com' }}
          MODEL: ${{ vars.OPENAI_MODEL || 'gpt-4o-mini' }}
          PROMPT: |
            You are a meticulous software maintainer.
            Return a minimal, safe patch that applies cleanly to the current HEAD.
            Output only a diff — no code fences, no explanations, no backticks.
            Acceptable formats:
            - Unified diff starting with:
              --- path/to/file
              +++ path/to/file
            - Git-style patch blocks starting with:
              diff --git a/path/to/file b/path/to/file

            Rules:
            - Target real paths in the repo (see snapshot).
            - For new files, use /dev/null in unified format or a proper diff --git header with new file mode.
            - Keep the patch small and directly related to the issue.

            Context:
            - Issue title: "${{ github.event.issue.title }}"
            - Issue body (may be empty): |
              ${{ github.event.issue.body }}

            Repository snapshot (filenames only):
            <<FILE_LIST>>
        run: |
          set -eu
          PROMPT_FULL="$(printf '%s\n\n%s' "$PROMPT" "$(cat prompt_context.txt)")"

          body=$(jq -n --arg model "$MODEL" --arg prompt "$PROMPT_FULL" '{
            model: $model,
            messages: [{ "role": "user", "content": $prompt }]
          }')

          echo "Sending request to OpenAI..."
          response=$(curl -sS -X POST "$OPENAI_BASE_URL/v1/chat/completions" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -d "$body")

          if echo "$response" | jq -e '.error' >/dev/null; then
            echo "OpenAI API returned an error:"
            echo "$response" | jq '.error'
            exit 1
          fi

          jq -r '.choices[0].message.content' <<<"$response" > raw.patch.txt

          echo "Raw model output (first 60 lines):"
          sed -n '1,60p' raw.patch.txt || true

      - name: Sanitise generated patch
        id: clean
        run: |
          set -eu
          # Remove surrounding code fences/backticks if present
          awk 'NR==1 && /^```/ {next} /^```$/ {next} {print}' raw.patch.txt > step1.txt

          # If the model added prose, drop everything before the first meaningful diff header
          awk '/^(diff --git |--- |\+\+\+ )/{s=1} s{print}' step1.txt > step2.txt || true

          # Normalise CRLF to LF
          tr -d '\r' < step2.txt > patch.diff || true

          echo "Sanitised patch preview (first 80 lines):"
          sed -n '1,80p' patch.diff || true

          # Simple sanity check: contain either unified headers or diff --git
          if ! grep -qE '^(diff --git |--- |\+\+\+ )' patch.diff; then
            echo "No diff headers detected after sanitisation."
            echo "Original model output (first 120 lines) for debugging:"
            sed -n '1,120p' raw.patch.txt || true
            exit 1
          fi

      - name: Apply proposed patch
        run: |
          set -eu
          echo "Validating patch applies cleanly (attempt 1)…"
          if git apply --check patch.diff 2>check1.err; then
            git apply patch.diff
            echo "Patch applied using default path strip."
          else
            echo "git apply --check failed (attempt 1). Diagnostics:"
            cat check1.err || true

            # If diff looks like 'a/ b/' style, retry with -p1
            if grep -qE '^(diff --git a/|--- a/|\+\+\+ b/)' patch.diff; then
              echo "Retrying with -p1 (attempt 2)…"
              if git apply -p1 --check patch.diff 2>check2.err; then
                git apply -p1 patch.diff
                echo "Patch applied with -p1."
              else
                echo "git apply --check failed again. Diagnostics:"
                cat check2.err || true
                echo "Repository tree (top level) for reference:"
                ls -la
                echo "First 120 lines of patch for debugging:"
                sed -n '1,120p' patch.diff || true
                exit 1
              fi
            else
              echo "Patch is not using a/ b/ prefixes; cannot auto-retry with -p1."
              echo "Repository tree (top level) for reference:"
              ls -la
              echo "First 120 lines of patch for debugging:"
              sed -n '1,120p' patch.diff || true
              exit 1
            fi
          fi

      - name: Commit and push changes
        id: push
        run: |
          set -eu

          # If nothing changed after applying the patch, skip gracefully
          if git diff --quiet; then
            echo "No changes detected after applying the patch. Skipping commit/push."
            echo "branch=" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Unique branch per run to avoid collisions
          branch="issue-${{ github.event.issue.number }}-${{ github.run_id }}"
          git checkout -b "$branch"

          git add -A

          # Skip if nothing staged
          if git diff --cached --quiet; then
            echo "No staged changes to commit. Skipping."
            echo "branch=" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          git commit -m "Proposed fix for issue #${{ github.event.issue.number }}"
          git push origin "$branch"
          echo "branch=$branch" >> "$GITHUB_OUTPUT"

      - name: Create pull request
        if: ${{ steps.push.outputs.branch != '' }}
        uses: actions/github-script@v7
        id: create_pr
        env:
          PR_BRANCH: ${{ steps.push.outputs.branch }}
          PR_BASE: ${{ github.event.repository.default_branch }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const head = process.env.PR_BRANCH;
            const base = process.env.PR_BASE;
            const title = `Proposed fix for issue #${{ github.event.issue.number }} - ${{ github.event.issue.title }}`;
            const body = [
              "This PR was automatically generated by the assistant workflow",
              "in response to issue #${{ github.event.issue.number }}.",
              "Please review the proposed patch below."
            ].join("\n");
            const { data: pr } = await github.rest.pulls.create({ owner, repo, head, base, title, body });
            core.setOutput("url", pr.html_url);

      - name: Comment on issue with PR link
        if: ${{ steps.create_pr.outputs.url != '' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prUrl = "${{ steps.create_pr.outputs.url }}";
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ github.event.issue.number }},
              body: [
                "Hello! A pull request has been automatically created for this issue:",
                prUrl,
                "",
                "Please review it when you have a moment."
              ].join("\n")
            });