name: Queue Worker

on:
  workflow_dispatch:
    inputs:
      queue_issue_number:
        description: "Issue number to process as the queue"
        required: false
        default: 1
  schedule:
    - cron: "*/10 * * * *" # kör var 10:e minut (justera efter behov)

permissions:
  contents: read
  issues: write

concurrency:
  group: queue-worker
  cancel-in-progress: false

jobs:
  process-one:
    name: Process one queued task
    runs-on: ubuntu-latest
    env:
      QUEUE_ISSUE: ${{ inputs.queue_issue_number || 1 }}
    steps:
      - name: Find oldest pending TASK comment
        id: find_task
        uses: actions/github-script@v7
        with:
          script: |
            const issue_number = parseInt(process.env.QUEUE_ISSUE, 10);
            const { owner, repo } = context.repo;

            // List comments (paginate backwards to get oldest first)
            let page = 1, per_page = 100, found = null;
            while (!found) {
              const { data: comments } = await github.rest.issues.listComments({
                owner, repo, issue_number, per_page, page
              });
              if (!comments.length) break;
              for (const c of comments) {
                const t = (c.body || "").trim();
                const isTask = t.startsWith("TASK:");
                const done = t.startsWith("DONE:") || t.includes("\nDONE:");
                const inprog = t.startsWith("IN-PROGRESS:") || t.includes("\nIN-PROGRESS:");
                if (isTask && !done && !inprog) { found = c; break; }
              }
              page++;
            }

            if (!found) {
              core.setOutput("found", "false");
              core.notice("No pending TASK comments found.");
              return;
            }

            // Lock it by marking as IN-PROGRESS
            const newBody = found.body.replace(/^TASK:/, "IN-PROGRESS:");
            await github.rest.issues.updateComment({
              owner, repo, comment_id: found.id, body: newBody
            });

            core.setOutput("found", "true");
            core.setOutput("comment_id", String(found.id));
            core.setOutput("original_body", found.body);

      - name: Stop if no task found
        if: steps.find_task.outputs.found != 'true'
        run: echo "Queue empty. Nothing to do."

      - name: Extract task payload
        if: steps.find_task.outputs.found == 'true'
        id: payload
        run: |
          python - << 'PY'
          import os, re, json, textwrap
          body = os.environ['BODY']
          # First line starts with TASK: <payload>
          first = body.splitlines()[0]
          payload = first.split("TASK:",1)[1].strip()
          print(f"::set-output name=task::{payload}")
          # Optional correlation id
          m = re.search(r'^correlation_id:\s*(.+)$', body, re.M|re.I)
          print(f"::set-output name=correlation_id::{(m.group(1).strip() if m else '')}")
          PY
        env:
          BODY: ${{ steps.find_task.outputs.original_body }}

      - name: Call OpenAI (example placeholder)
        if: steps.find_task.outputs.found == 'true'
        id: openai
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          TASK: ${{ steps.payload.outputs.task }}
        run: |
          if [ -z "$OPENAI_API_KEY" ]; then
            echo "No OPENAI_API_KEY provided; producing a stub result."
            echo "result=// STUB: processed \"$TASK\"" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Example minimal Chat Completions call (adjust to your model/prompting)
          RESPONSE=$(curl -sS https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d "$(jq -n --arg t "$TASK" '{
                  model: "gpt-4o-mini",
                  messages: [
                    {role:"system", content:"You are a helpful worker that returns concise outputs."},
                    {role:"user", content: ("Process this task: " + $t)}
                  ],
                  temperature: 0.2
                }')")

          RESULT=$(echo "$RESPONSE" | jq -r '.choices[0].message.content // "No result"')
          echo "result<<__EOF__" >> $GITHUB_OUTPUT
          echo "$RESULT" >> $GITHUB_OUTPUT
          echo "__EOF__" >> $GITHUB_OUTPUT

      - name: Mark DONE and post result
        if: steps.find_task.outputs.found == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const comment_id = parseInt("${{ steps.find_task.outputs.comment_id }}", 10);

            // Mark the original comment as DONE
            const orig = `${{ toJSON(steps.find_task.outputs.original_body) }}`;
            const doneBody = orig.replace(/^TASK:/, "DONE:");
            await github.rest.issues.updateComment({
              owner, repo, comment_id, body: doneBody
            });

            // Reply with result
            const issue_number = parseInt(process.env.QUEUE_ISSUE, 10);
            const result = `${{ toJSON(steps.openai.outputs.result) }}`;
            await github.rest.issues.createComment({
              owner, repo, issue_number,
              body: [
                "✅ **Task processed**",
                "",
                "**Result:**",
                "",
                result
              ].join("\n")
            });