name: Codex Auto PRs

on:
  issues:
    types: [opened, reopened]
  pull_request:
    types: [opened, reopened, ready_for_review, synchronize]
  workflow_dispatch:
    inputs:
      parallel_limit:
        description: "Max parallel Codex jobs"
        type: number
        required: false
        default: 3
  # schedule:
  #   - cron: "0 * * * *"

permissions:
  contents: write
  pull-requests: write
  issues: write

concurrency:
  group: codex-global
  cancel-in-progress: false

env:
  CODEX_LABEL: codex
  CODEX_PREFIX: codex/issue-
  SKIP_LABEL: discussion
  DEFAULT_PARALLEL: 3

jobs:
  prepare_targets:
    if: github.event_name != 'pull_request'
    runs-on: ubuntu-latest
    concurrency:
      group: >-
        prepare-${{ github.event_name }}-${{ github.event.issue.number || github.run_id }}
      cancel-in-progress: false
    outputs:
      targets: ${{ steps.set-matrix.outputs.targets }}
      parallel: ${{ steps.compute-parallel.outputs.parallel }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Enable GH debug
        run: |
          echo "GH_CLI_VERSION:"
          gh --version
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Decide parallel limit
        id: compute-parallel
        shell: bash
        run: |
          set -euo pipefail
          PL="${{ github.event.inputs.parallel_limit }}"
          if [[ -z "${PL:-}" || ! "$PL" =~ ^[0-9]+$ || "$PL" -le 0 ]]; then
            PL="${DEFAULT_PARALLEL}"
          fi
          echo "parallel=$PL" >> "$GITHUB_OUTPUT"

      - name: Find default branch
        id: default-branch
        shell: bash
        run: |
          set -euo pipefail
          DB="${{ github.event.repository.default_branch }}"
          if [[ -z "${DB:-}" ]]; then
            DB="$(gh api repos/${{ github.repository }} -q .default_branch)"
          fi
          echo "name=$DB" >> "$GITHUB_OUTPUT"
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Collect issues (open, excluding 'discussion')
        id: collect-issues
        shell: bash
        run: |
          jq -n '[]' > issues.json
          gh api graphql -f query='
          query($owner:String!, $repo:String!, $cursor:String) {
            repository(owner:$owner, name:$repo) {
              issues(first:100, states:OPEN, after:$cursor, orderBy:{field:CREATED_AT, direction:ASC}) {
                pageInfo { hasNextPage endCursor }
                nodes { number title labels(first:50){ nodes { name } } }
              }
            }
          }' -F owner="${{ github.repository_owner }}" -F repo="${{ github.event.repository.name }}" --paginate \
          | jq -r '
            [ .data.repository.issues.nodes[]
              | select( [(.labels.nodes[]?.name // "") | ascii_downcase]
                        | index("'"${SKIP_LABEL,,}"'") | not )
            ]' > issues.json
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Drop issues that already have a merged PR linked
        id: filter-merged
        shell: bash
        run: |
          set -euo pipefail
          cp issues.json remaining.json
          tmp="$(mktemp)"
          jq -c '.[]' remaining.json | while read -r issue; do
            num="$(jq -r .number <<<"$issue")"
            q='
            query($owner:String!, $repo:String!, $num:Int!) {
              repository(owner:$owner, name:$repo) {
                issue(number:$num) {
                  timelineItems(itemTypes:[CROSS_REFERENCED_EVENT], first:100) {
                    nodes {
                      ... on CrossReferencedEvent {
                        source {
                          __typename
                          ... on PullRequest { number merged state isCrossRepository }
                        }
                      }
                    }
                  }
                }
              }
            }'
            data="$(gh api graphql -f query="$q" -F owner="${{ github.repository_owner }}" -F repo="${{ github.event.repository.name }}" -F num="$num")"
            hasMerged="$(jq '[.data.repository.issue.timelineItems.nodes[]
              | select(.source.__typename=="PullRequest")
              | .source
              | select(.merged==true or .state=="MERGED")] | length > 0' <<<"$data")"
            if [[ "$hasMerged" == "true" ]]; then
              echo "Issue #$num already has a merged PR; skipping."
              continue
            fi
            echo "$issue" >> "$tmp"
          done
          if [[ -s "$tmp" ]]; then jq -s '.' "$tmp" > remaining.json; else jq -n '[]' > remaining.json; fi
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Ensure codex branches & draft PRs exist per issue
        id: build-targets
        shell: bash
        run: |
          set -euo pipefail
          DB="${{ steps.default-branch.outputs.name }}"
          git fetch origin "$DB"
          git checkout "$DB"
          jq -n '[]' > targets.json
          jq -c '.[]' remaining.json | while read -r issue; do
            num="$(jq -r .number <<<"$issue")"
            title="$(jq -r .title <<<"$issue")"
            slug="$(tr -cd '[:alnum:]- ' <<<"$title" | tr '[:upper:] ' '[:lower:]-' | sed -E 's/-+/-/g;s/^-+//;s/-+$//' | cut -c1-40)"
            branch="${CODEX_PREFIX}${num}-${slug}"
            if git ls-remote --exit-code --heads origin "refs/heads/$branch" >/dev/null 2>&1; then
              echo "Reusing branch $branch"
              git fetch origin "$branch"
            else
              echo "Creating branch $branch from $DB"
              git checkout -b "$branch" "origin/$DB"
              git commit --allow-empty -m "chore(codex): initial draft for issue #$num"
            fi
            pr_json="$(gh pr list --head "$branch" --json number,isDraft -q '.[0] // empty' || true)"
            if [[ -z "$pr_json" ]]; then
              echo "Creating draft PR for $branch"
              pr_number="$(gh pr create \
                --head "$branch" \
                --base "$DB" \
                --draft \
                --title "WIP: $title (#$num)" \
                --body "Closes #$num" \
                --json number -q .number)"
            else
              pr_number="$(jq -r .number <<<"$pr_json")"
              echo "Draft PR already exists: #$pr_number"
            fi
            # append to targets.json without sponge
            tmp_targets="$(mktemp)"
            jq --arg b "$branch" --argjson n "$pr_number" \
              '. + [{branch:$b, pr_number:$n}]' targets.json > "$tmp_targets"
            mv "$tmp_targets" targets.json
          done
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Include all open PRs (manual dispatch only)
        if: github.event_name == 'workflow_dispatch'
        shell: bash
        run: |
          set -euo pipefail
          jq -n '[]' > open_prs.json
          gh pr list --state open --json number,headRefName \
          | jq '[ .[] | {branch:.headRefName, pr_number:.number} ]' > open_prs.json
          jq -s '
            def uniq_by_branch: unique_by(.branch);
            (.[0] + .[1]) | uniq_by_branch
          ' targets.json open_prs.json > merged.json
          mv merged.json targets.json
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Set matrix outputs
        id: set-matrix
        shell: bash
        run: |
          set -euo pipefail
          T="$(cat targets.json)"
          echo "targets=$T" >> "$GITHUB_OUTPUT"
          echo "Prepared targets:"
          echo "$T" | jq -r '.[] | "- \(.branch) (PR #\(.pr_number))"'

  codex_on_targets:
    name: Codex on targets
    needs: [prepare_targets]
    if: needs.prepare_targets.outputs.targets != '[]' && needs.prepare_targets.outputs.targets != ''
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        max-parallel: ${{ fromJSON(needs.prepare_targets.outputs.parallel) }}
        target: ${{ fromJSON(needs.prepare_targets.outputs.targets) }}
    concurrency:
      group: codex-${{ matrix.target.branch }}
      cancel-in-progress: false
    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ matrix.target.branch }}
          fetch-depth: 0

      - name: Fetch PR metadata
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          NUM="${{ matrix.target.pr_number }}"
          DATA="$(gh pr view "$NUM" --json number,title,body,headRefName,baseRefName,baseRefOid,headRefOid)"
          echo "title=$(jq -r .title <<<"$DATA")" >> "$GITHUB_OUTPUT"
          echo "body<<EOF" >> "$GITHUB_OUTPUT"
          jq -r .body <<<"$DATA" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "base=$(jq -r .baseRefName <<<"$DATA")" >> "$GITHUB_OUTPUT"
          echo "head=$(jq -r .headRefName <<<"$DATA")" >> "$GITHUB_OUTPUT"
          echo "base_sha=$(jq -r .baseRefOid <<<"$DATA")" >> "$GITHUB_OUTPUT"
          echo "head_sha=$(jq -r .headRefOid <<<"$DATA")" >> "$GITHUB_OUTPUT"
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Detect linked issues (GraphQL, then branch fallback)
        id: linked
        shell: bash
        run: |
          NUM="${{ matrix.target.pr_number }}"
          q='
          query($owner:String!, $repo:String!, $num:Int!){
            repository(owner:$owner, name:$repo){
              pullRequest(number:$num){
                closingIssuesReferences(first:10){ nodes { number title } }
              }
            }
          }'
          data="$(gh api graphql -f query="$q" -F owner="${{ github.repository_owner }}" -F repo="${{ github.event.repository.name }}" -F num="$NUM")"
          list="$(jq '[.data.repository.pullRequest.closingIssuesReferences.nodes[]?.number] // []' <<<"$data")"
          if [[ "$(jq 'length' <<<"$list")" -eq 0 ]]; then
            b="${{ matrix.target.branch }}"
            issue_num="$(grep -Eo 'issue-([0-9]+)' <<<"$b" | head -1 | cut -d- -f2 || true)"
            if [[ -n "${issue_num:-}" ]]; then list="[$issue_num]"; fi
          fi
          echo "issues=$list" >> "$GITHUB_OUTPUT"
          echo "Linked issues: $list"
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Run Codex to apply minimal, targeted changes
        id: codex
        uses: openai/codex-action@v1
        with:
          openai-api-key: ${{ secrets.OPENAI_API_KEY }}
          prompt: ${{ env.CODEX_PROMPT }}
        env:
          GITHUB_TOKEN: ${{ github.token }}
          CODEX_PROMPT: |
            You are an automated contributor on a GitHub Pull Request.
            Make the smallest, targeted changes necessary to resolve the linked issue(s): ${{ steps.linked.outputs.issues }}.
            Keep scope tight; update tests and docs as needed.
            Do not introduce unrelated refactors.
            After applying changes, print a concise "Change summary:" list of what you touched.

      - name: Commit & push if changed
        id: commit
        shell: bash
        run: |
          set -euo pipefail
          git config user.name "codex-bot"
          git config user.email "codex-bot@users.noreply.github.com"
          if [[ -n "$(git status --porcelain)" ]]; then
            git add -A
            git commit -m "codex: minimal edits for ${{ steps.linked.outputs.issues }}"
            git push
            echo "changed=true" >> "$GITHUB_OUTPUT"
          else
            echo "No changes from Codex."
            echo "changed=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Ensure label exists & mark ready if changed
        if: steps.commit.outputs.changed == 'true'
        shell: bash
        run: |
          set -euo pipefail
          NUM="${{ matrix.target.pr_number }}"
          gh api --method GET repos/${{ github.repository }}/labels/${CODEX_LABEL} >/dev/null 2>&1 || \
          gh api --method POST repos/${{ github.repository }}/labels -f name="${CODEX_LABEL}" -f description='Changes produced by Codex automation'
          gh pr edit "$NUM" --add-label "${CODEX_LABEL}"
          gh pr ready "$NUM"
        env:
          GH_TOKEN: ${{ github.token }}

  pr_codex:
    if: github.event_name == 'pull_request'
    name: Codex on PR event
    runs-on: ubuntu-latest
    concurrency:
      group: codex-pr-${{ github.event.pull_request.number }}
      cancel-in-progress: false
    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}
          fetch-depth: 0

      - name: Fetch PR metadata
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          NUM="${{ github.event.pull_request.number }}"
          DATA="$(gh pr view "$NUM" --json number,title,body,headRefName,baseRefName)"
          echo "title=$(jq -r .title <<<"$DATA")" >> "$GITHUB_OUTPUT"
          echo "body<<EOF" >> "$GITHUB_OUTPUT"
          jq -r .body <<<"$DATA" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Detect linked issues (closingIssuesReferences)
        id: linked
        shell: bash
        run: |
          set -euo pipefail
          NUM="${{ github.event.pull_request.number }}"
          q='
          query($owner:String!, $repo:String!, $num:Int!){
            repository(owner:$owner, name:$repo){
              pullRequest(number:$num){
                closingIssuesReferences(first:10){ nodes { number title } }
              }
            }
          }'
          data="$(gh api graphql -f query="$q" -F owner="${{ github.repository_owner }}" -F repo="${{ github.event.repository.name }}" -F num="$NUM")"
          list="$(jq '[.data.repository.pullRequest.closingIssuesReferences.nodes[]?.number] // []' <<<"$data")"
          echo "issues=$list" >> "$GITHUB_OUTPUT"
          echo "Linked issues: $list"
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Run Codex to refine or complete the PR
        id: codex
        uses: openai/codex-action@v1
        with:
          openai-api-key: ${{ secrets.OPENAI_API_KEY }}
          prompt: ${{ env.CODEX_PROMPT }}
        env:
          GITHUB_TOKEN: ${{ github.token }}
          CODEX_PROMPT: |
            This PR should address issues: ${{ steps.linked.outputs.issues }}.
            Improve or complete the implementation with minimal, targeted edits.
            Keep changes scoped; update tests/docs as needed.
            Output a concise "Change summary:" of modifications.

      - name: Commit & push if changed
        id: commit
        shell: bash
        run: |
          set -euo pipefail
          git config user.name "codex-bot"
          git config user.email "codex-bot@users.noreply.github.com"
          if [[ -n "$(git status --porcelain)" ]]; then
            git add -A
            git commit -m "codex: refine PR for ${{ steps.linked.outputs.issues }}"
            git push
            echo "changed=true" >> "$GITHUB_OUTPUT"
          else
            echo "No changes from Codex."
            echo "changed=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Ensure label exists & mark ready if changed
        if: steps.commit.outputs.changed == 'true'
        shell: bash
        run: |
          set -euo pipefail
          NUM="${{ github.event.pull_request.number }}"
          gh api --method GET repos/${{ github.repository }}/labels/${CODEX_LABEL} >/dev/null 2>&1 || \
          gh api --method POST repos/${{ github.repository }}/labels -f name="${CODEX_LABEL}" -f description='Changes produced by Codex automation'
          gh pr edit "$NUM" --add-label "${CODEX_LABEL}"
          gh pr ready "$NUM"
        env:
          GH_TOKEN: ${{ github.token }}