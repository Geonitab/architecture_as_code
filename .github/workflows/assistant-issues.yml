name: Manual text to multiple GitHub issues (British English)

on:
  workflow_dispatch:
    inputs:
      source_text:
        description: "Paste your backlog text here (free-form)."
        required: true
        default: ""
      dry_run:
        description: "Preview only (true/false). Default: true"
        required: true
        default: ""

permissions:
  contents: read
  issues: write

jobs:
  create_issues:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ensure tools are available
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq

      - name: Save pasted text
        env:
          SOURCE_TEXT: ${{ github.event.inputs.source_text }}
        run: |
          set -euo pipefail
          printf '%s' "$SOURCE_TEXT" > /tmp/source.txt
          echo "Preview of first lines:"
          head -n 20 /tmp/source.txt || true

      - name: Transform to British English via OpenAI (robust)
        id: openai
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          set -euo pipefail

          # 1) Write instruction text to file with 10-space indentation (including EOF)
          cat > /tmp/instruct.txt << '          EOF'
          You are an expert product editor who creates concise GitHub issues in British English.

          INPUT: One free-form text that may contain headings, bullet points, numbered lists, or paragraphs describing multiple work items.

          SPLITTING RULES:
          - Split into distinct issues whenever a new item is indicated (headings, bullets, numbered points, blank lines, or prefixes like "Bug:", "Fix:", "Feature:", "Docs:").
          - If one chunk clearly contains multiple tasks, split further.
          - Remove duplicates; keep the clearest version.

          FOR EACH ISSUE, PRODUCE:
          - title_british: concise, actionable, British spelling, no emojis.
          - body_british (Markdown):
            * Summary (1–3 sentences)
            * Acceptance criteria (bullet list if possible)
            * Context/Notes (optional)
            * Priority (if mentioned)
          - labels: at most 1–2 from {bug, enhancement, documentation, chore}.
          - assignees: include usernames if present (without the "@").

          OUTPUT:
          Return ONLY strict JSON in this schema (UTF-8, no trailing commas):
          {"issues":[{"title_british":"string","body_british":"string","labels":["string"],"assignees":["string"]}]}
          No explanations outside the JSON.
          EOF

          # 2) Convert instruction file to safe JSON string
          INSTRUCT=$(jq -Rs '.' /tmp/instruct.txt)
          CONTENT=$(cat /tmp/source.txt)

          # 3) Build request JSON safely
          REQUEST=$(jq -n --arg instruct "$INSTRUCT" --arg content "$CONTENT" '
            {
              model: "gpt-4o-mini",
              input: [
                {role:"system", content:"Return JSON only. No explanations."},
                {role:"user", content: ($instruct | fromjson)},
                {role:"user", content: ("TEXT:\n" + $content)}
              ]
            }')

          echo "::group::OpenAI API Request"
          echo "$REQUEST" | jq .
          echo "::endgroup::"

          # 4) Call the API and capture HTTP status
          HTTP_CODE=$(mktemp)
          curl -sS https://api.openai.com/v1/responses \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -o /tmp/response.json \
            -w "%{http_code}" \
            -d "$REQUEST" > "$HTTP_CODE" || true

          STATUS=$(cat "$HTTP_CODE" || echo "000")
          echo "::group::OpenAI API Response"
          cat /tmp/response.json || true
          echo
          echo "HTTP status: $STATUS"
          echo "::endgroup::"

          if [ "$STATUS" != "200" ]; then
            echo "Non-200 from OpenAI: $STATUS"
            if jq -e . >/dev/null 2>&1 < /tmp/response.json; then
              jq . /tmp/response.json
            else
              cat /tmp/response.json
            fi
            exit 1
          fi

          jq -e . >/dev/null < /tmp/response.json || { echo "Response not valid JSON"; exit 1; }

          if jq -e '.error' >/dev/null < /tmp/response.json; then
            echo "OpenAI returned an error object:"
            jq .error /tmp/response.json
            exit 1
          fi

          RAW=$(
            jq -r '
              .output_text //
              (.output[]?.content[]? | select(.text != null) | .text) //
              (.content[]? | select(.text != null) | .text) //
              empty
            ' /tmp/response.json
          )

          if [ -z "$RAW" ]; then
            echo "Model returned empty output_text/content."
            jq . /tmp/response.json || true
            exit 1
          fi

          echo "$RAW" | jq -e '.issues and (.issues|type=="array")' > /tmp/issues.json
          COUNT=$(jq '.issues|length' /tmp/issues.json)
          echo "count=$COUNT" >> "$GITHUB_OUTPUT"
          echo "Proposed issues: $COUNT"

      - name: Preview or create issues
        if: ${{ steps.openai.outputs.count && steps.openai.outputs.count != '0' }}
        uses: actions/github-script@v7
        env:
          DRY_RUN: ${{ github.event.inputs.dry_run }}
        with:
          script: |
            const fs = require('fs');
            const core = require('@actions/core');
            const dryRun = (process.env.DRY_RUN || 'true').toLowerCase() === 'true';
            const data = JSON.parse(fs.readFileSync('/tmp/issues.json', 'utf8'));
            const items = Array.isArray(data.issues) ? data.issues : [];

            let summary = `### Proposed Issues (${items.length})\n`;
            for (let i = 0; i < items.length; i++) {
              const it = items[i] || {};
              summary += `\n#### ${i + 1}. ${it.title_british || '(no title)'}\n`;
              summary += `${(it.body_british || '').slice(0, 500)}\n`;
              summary += `**Labels:** ${(it.labels || []).join(', ') || '(none)'}\n`;
              summary += `**Assignees:** ${(it.assignees || []).join(', ') || '(none)'}\n`;
            }

            if (dryRun) {
              core.info('Dry run: no issues will be created.');
              await core.summary.addHeading('Dry Run Summary').addRaw(summary).write();
              return;
            }

            const existing = await github.paginate(github.rest.issues.listForRepo, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 100
            });
            const existingTitles = new Set(existing.map(i => (i.title || '').trim().toLowerCase()));

            let created = 0;
            for (const it of items) {
              const title = (it.title_british || '').trim();
              if (!title) continue;
              if (existingTitles.has(title.toLowerCase())) {
                core.info(`Skip duplicate: ${title}`);
                continue;
              }
              const body = (it.body_british || '').trim();
              const labels = Array.isArray(it.labels) ? it.labels : [];
              const assignees = Array.isArray(it.assignees) ? it.assignees : [];

              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title,
                body,
                labels,
                assignees
              });
              created++;
            }

            await core.summary
              .addHeading('Issue Creation Summary')
              .addRaw(`Created: ${created} issue(s).\n`)
              .addRaw(summary)
              .write();