<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://aac.geon.se/02_fundamental_principles/" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Fundamental Principles of Architecture as Code - Architecture as Code at aac.geon.se</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../stylesheets/code-dark.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Fundamental Principles of Architecture as Code";
        var mkdocs_page_input_path = "02_fundamental_principles.md";
        var mkdocs_page_url = "/02_fundamental_principles/";
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> Architecture as Code at aac.geon.se
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Overview</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="..">Welcome</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../book_structure/">Book Structure</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../documentation_workflow/">Documentation and Architecture Contribution Workflow</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Part A – Foundations</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../part_a_foundations/">index</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../01_introduction/">Introduction to Architecture as Code</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">Fundamental Principles of Architecture as Code</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#declarative-architecture-definition">Declarative architecture definition</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#holistic-perspective-on-codification">Holistic perspective on codification</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#adoptability-first-enablement">Adoptability-first enablement</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#extensibility-by-design">Extensibility by design</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#productivity-through-automation">Productivity through automation</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#historical-lessons-from-model-driven-development">Historical lessons from model-driven development</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#implementation-timeline-for-architecture-as-code">Implementation timeline for Architecture as Code</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#architecture-as-a-single-source-of-truth">Architecture as a single source of truth</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#git-governed-maintainability-guardrails">Git-governed maintainability guardrails</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#immutable-architecture-patterns">Immutable architecture patterns</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#understanding-architectural-drift">Understanding architectural drift</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#causes-of-architectural-drift">Causes of architectural drift</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#consequences-of-architectural-drift">Consequences of architectural drift</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#how-architecture-as-code-prevents-drift">How Architecture as Code prevents drift</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#drift-detection-and-remediation">Drift detection and remediation</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#testability-at-the-architecture-level">Testability at the architecture level</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#documentation-as-code">Documentation as Code</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#benefits-of-documentation-as-code">Benefits of Documentation as Code</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#practical-implementation">Practical implementation</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#requirements-as-code">Requirements as Code</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#automation-and-traceability">Automation and traceability</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#practical-example-with-open-policy-agent-opa">Practical example with Open Policy Agent (OPA)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#validation-and-test-automation">Validation and test automation</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#functional-vs-non-functional-requirements-as-code">Functional vs Non-Functional Requirements as Code</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#the-v-model-and-requirements-verification">The V-Model and Requirements Verification</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#practical-implementation-patterns">Practical Implementation Patterns</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#testability-characteristics">Testability Characteristics</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#implications-for-architecture-as-code">Implications for Architecture as Code</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../03_version_control/">Version Control and Code Structure</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../04_adr/">Architecture Decision Records (ADR)</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Part B – Architecture Platform</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../part_b_platform/">index</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../05_automation_devops_cicd/">Automation, DevOps and CI/CD for Infrastructure as Code</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../06_structurizr/">Structurizr: Architecture Modelling as Code</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../07_containerisation/">Containerisation and Orchestration as Code</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../08_microservices/">Microservices Architecture as Code</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Part C – Security & Governance</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../part_c_security/">index</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../09_security_fundamentals/">Security Fundamentals for Architecture as Code</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../09b_security_patterns/">Advanced Security Patterns and Implementation</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../09c_risk_and_threat_as_code/">Risk and Threat Modelling as Code</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../10_policy_and_security/">Policy and Security as Code in Detail</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../11_governance_as_code/">Governance as Code</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../12_compliance/">Compliance and Regulatory Adherence</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Part D – Delivery & Operations</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../part_d_delivery/">index</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../13_testing_strategies/">Testing Strategies for Infrastructure as Code</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../14_practical_implementation/">Architecture as Code in Practice</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../15_evidence_as_code/">Evidence as Code and Continuous Assurance</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../15_cost_optimization/">Cost Optimisation and Resource Management</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../16_migration/">Migration from Traditional Infrastructure</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Part E – Organisation & Leadership</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../part_e_leadership/">index</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../17_organisational_change/">Organisational Change and Team Structures</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../18_team_structure/">Team Structure and Competency Development for IaC</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../19_management_as_code/">Management as Code</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../20_ai_agent_team/">AI Agent Team for Architecture as Code Initiatives</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../21_digitalisation/">Digitalisation through Code-based Infrastructure</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Part F – Experience & Best Practices</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../part_f_practices/">index</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../22_documentation_vs_architecture/">Documentation as Code vs Architecture as Code</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../23_soft_as_code_interplay/">Interplay Between Soft-As-Code Disciplines</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../24_best_practices/">Best Practices and Lessons Learned</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Part G – Future & Wrap-up</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../part_g_future/">index</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../25_future_trends/">Future Trends in Architecture as Code</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../26a_prerequisites_for_aac/">Prerequisites for Architecture as Code Adoption</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../26b_aac_anti_patterns/">Anti-Patterns in Architecture as Code Programmes</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../27_conclusion/">Conclusion</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Appendices</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../part_h_appendices/">Part H – Appendices and Reference Overview</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../28_glossary/">Glossary</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../29_about_the_authors/">About the Author</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../30_appendix_code_examples/">Appendix A – Code Examples and Technical Implementations</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../appendix_b_technical_architecture/">Appendix B – Technical Architecture for Book Production</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../appendix_templates_and_tools/">Templates and Tools Appendix</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../32_finos_project_blueprint/">Appendix C – FINOS Project Blueprint</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../architecture_as_code_maturity_model/">Appendix D – Architecture as Code Maturity Model</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../maturity_model_radar.html">Appendix E – Architecture as Code Maturity Radar Tool</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../33_references/">References and Sources</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../appendix_f_control_mapping_matrix_template/">Appendix F – Control Mapping Matrix Template</a>
                  </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../prezi/">Prezi Deck</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">Architecture as Code at aac.geon.se</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">Part A – Foundations</li>
      <li class="breadcrumb-item active">Fundamental Principles of Architecture as Code</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/geonitab/architecture_as_code/edit/master/docs/02_fundamental_principles.md">Edit on architecture_as_code</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="fundamental-principles-of-architecture-as-code">Fundamental Principles of Architecture as Code</h1>
<p>Architecture as Code is founded on core principles that enable successful implementation of codified system architecture. These principles span the entire system landscape and provide a holistic view of architecture management.</p>
<p><img alt="Fundamental principles diagram" src="../images/diagram_02_chapter1.png" /></p>
<p>The diagram illustrates the natural flow from declarative code through version control and automation to reproducibility and scalability – the five foundational pillars of Architecture as Code.</p>
<h2 id="declarative-architecture-definition">Declarative architecture definition</h2>
<p>The declarative approach in Architecture as Code describes the desired system state at every level – from application components to infrastructure. This contrasts with imperative programming, where each step must be specified explicitly.</p>
<p>Declarative definitions make it possible to express an architecture's intended state, extending Architecture as Code to cover application architecture, API contracts, and organisational structures.</p>
<h2 id="holistic-perspective-on-codification">Holistic perspective on codification</h2>
<p>Architecture as Code embraces the full system ecosystem through a holistic lens. It includes application logic, data flows, security policies, compliance rules, and organisational structures.</p>
<p>A practical example is an application programming interface change automatically propagating through the architecture – from security configurations to documentation – all defined as code.</p>
<h3 id="adoptability-first-enablement">Adoptability-first enablement</h3>
<p>Red Hat (2023) frames adoptability as the entry point for Architecture as Code: the language, repository layout, and review rituals must be simple enough that architects, engineers, and governance specialists can contribute without specialist tooling. Pattern libraries, sample pull requests, and role-based contribution guides help teams join the workflow gradually while still building confidence that architectural intent is preserved.</p>
<h3 id="extensibility-by-design">Extensibility by design</h3>
<p>Extensibility keeps the practice resilient as new platforms and compliance regimes emerge. Red Hat recommends treating architecture models as modular building blocks, exposing clear extension points for automation, security scanning, and reporting. Declarative schemas, reusable validation libraries, and plug-in interfaces let teams add new capability without rewriting the foundational architecture definitions.</p>
<h3 id="productivity-through-automation">Productivity through automation</h3>
<p>Productivity is the payoff for codifying architecture. With architecture changes expressed as pull requests, automation can lint models, execute policy checks, regenerate diagrams, and publish documentation autonomously. Red Hat notes that this automation-first mindset removes approval bottlenecks and gives architects rapid feedback, allowing them to focus on higher-order decision-making instead of status tracking.</p>
<h3 id="historical-lessons-from-model-driven-development">Historical lessons from model-driven development</h3>
<p>Model-Driven Development (MDD) grew out of decades of domain-specific modelling work and the Object Management Group's Model Driven Architecture manifesto (OMG, 2001). The promise of lifting platform-independent models into generated, platform-specific implementations resonated strongly in telecoms, aerospace, and defence programmes where delivery stacks were tightly controlled. Schmidt (2006) highlights how those focused domains achieved tangible gains by keeping executable models aligned with the code generators that teams owned end-to-end, demonstrating the value of codifying architectural knowledge.</p>
<p>Wider industry adoption exposed the limits of that optimism. Selic (2003) documents how brittle round-trip engineering, tool lock-in, and ambiguous semantics caused MDD artefacts to fall out of sync as soon as teams customised generated code or adopted new frameworks. Architecture as Code internalises those lessons by favouring lightweight textual models, explicit version control, and continuous validation so that the architecture specification evolves alongside implementation rather than trying to replace it.</p>
<p>Modern MBSE-aligned tooling such as Structurizr focuses on keeping a single authoritative architecture model close to the codebase, generating diagrams and reviews from that source without enforcing fragile full-code generation. This pragmatic approach provides the automation benefits MDD aspired to while preserving developer autonomy, making Architecture as Code a practical successor that avoids the historical pitfalls identified by Selic (2003).</p>
<h2 id="implementation-timeline-for-architecture-as-code">Implementation timeline for Architecture as Code</h2>
<p>The foundational principles manifest through a staged adoption journey. Establishing declarative definitions, codifying guardrails in version control, and automating validation require coordinated investment across architecture, platform, and governance teams.</p>
<p><img alt="Architecture as Code implementation timeline" src="../images/diagram_05_gantt_timeline.png" /></p>
<p>The implementation roadmap introduces the foundations long before automation is rolled out across the estate. Discovery, codification, and enablement run in parallel so that by the time Architecture as Code reaches production, every pillar in this chapter is already embedded in day-to-day delivery.</p>
<table>
<thead>
<tr>
<th>Phase</th>
<th>Duration</th>
<th>Primary focus</th>
<th>Principles reinforced</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Foundation</strong></td>
<td>Weeks 1–8</td>
<td>Evaluate tools, train the core team, structure repositories, and codify the baseline architecture</td>
<td>Declarative architecture definition, holistic codification</td>
</tr>
<tr>
<td><strong>Development</strong></td>
<td>Weeks 6–20</td>
<td>Develop reusable templates, implement testing frameworks, stand up CI/CD pipelines, and validate security controls</td>
<td>Immutable architecture patterns, testability at the architecture level, automation guardrails</td>
</tr>
<tr>
<td><strong>Production</strong></td>
<td>Weeks 18–32</td>
<td>Pilot immutable deployments, refine based on feedback, expand monitoring, and complete knowledge transfer</td>
<td>Documentation as code, continuous reconciliation, organisation-wide adoption</td>
</tr>
</tbody>
</table>
<p>Organisations can adjust exact timing to match their scale and regulatory obligations, but maintaining this sequencing prevents downstream teams from adopting automation without a provable architectural baseline. The timeline also clarifies ownership: architecture leaders deliver the canonical models, platform teams build the automation layers, and governance teams monitor adherence once production rollout begins.</p>
<h2 id="architecture-as-a-single-source-of-truth">Architecture as a single source of truth</h2>
<p>Delivering Architecture as Code as a single source of truth (SSOT) demands shared responsibilities across interfaces. GitLab (2024) documents how platform teams expose a hardened command-line interface for everyday contributors, coupling familiar Git flows with guardrail scripts that validate models before merge. The same SSOT repository publishes an API that downstream systems use to synchronise diagrams, catalogues, and service metadata; governance and reporting platforms consume those endpoints to guarantee they always reflect the approved architecture. By curating both CLI and API experiences, maintainers keep architectural knowledge authoritative, while product teams gain self-service access to the latest canon without bypassing change control.</p>
<h3 id="git-governed-maintainability-guardrails">Git-governed maintainability guardrails</h3>
<p>Long-lived maintainability depends on storing every architectural artefact—models, ADRs, compliance policies, and supporting narratives—in version control so that the history of architectural intent travels with the codebase. GitHub's protected branch policy (Source [4]) reinforces this expectation by requiring reviews, status checks, and signed commits before architectural updates reach the canonical branch. Architecture as Code teams should treat architectural pull requests exactly like application pull requests: they run the same automated validation suites, capture rationale in review comments, and only merge when both architectural and implementation stakeholders approve the change set.</p>
<ul>
<li><strong>Trunk-based guardrails</strong>: Teams keeping architecture definitions on a single <code>main</code> branch create short-lived feature branches whenever strategic decisions evolve. Mandatory reviewers include at least one architect and one delivery engineer, while continuous integration pipelines render Structurizr diagrams, execute policy-as-code tests, and trigger the documentation workflow described in <a href="../22_documentation_vs_architecture/">Chapter 22</a>. This combination means a pull request cannot merge until the architecture DSL, executable policies, and accompanying narrative stay aligned, reducing the drift scenarios highlighted earlier in this chapter.</li>
<li><strong>GitFlow with architectural release gates</strong>: Organisations preferring GitFlow can adapt the model by storing executable architecture on the <code>develop</code> branch and promoting it through protected release branches. Each promotion bundles architecture changes with updated documentation-as-code artefacts so that release candidates include both diagrams and explanatory guides. Protected branch rules (Source [4]) enforce multi-role approvals and require the documentation pipeline to succeed before merge, ensuring programme governance has clear checkpoints even when hotfix branches exist.</li>
</ul>
<p>Pairing these Git workflows with the documentation-as-code techniques outlined in Chapter 22 keeps diagrams, prose, and architecture models synchronised. Contributors amend Structurizr or CALM models in the same change set as Mermaid diagrams and Markdown updates, and the automated checks from <code>docs/documentation_workflow.md</code> prevent divergence between the artefacts. By integrating review cadences, automation, and documentation into a single version-controlled workflow, Architecture as Code remains a living, maintainable discipline rather than a snapshot of intent.</p>
<h2 id="immutable-architecture-patterns">Immutable architecture patterns</h2>
<p>The principle of immutable architecture keeps the entire system architecture under control through immutable components. Rather than modifying existing parts, new versions are created that replace older ones at every level.</p>
<p>This approach fosters predictability and eliminates architectural drift, where systems gradually diverge from their intended design over time.</p>
<h3 id="understanding-architectural-drift">Understanding architectural drift</h3>
<p>Architectural drift is a gradual, often unintentional deviation of a system's actual implementation from its intended architectural design. This phenomenon occurs when incremental changes, workarounds, emergency fixes, and undocumented modifications accumulate over time, causing the running system to diverge from its documented architecture and original design principles.</p>
<h4 id="causes-of-architectural-drift">Causes of architectural drift</h4>
<p>Several factors contribute to architectural drift in traditional systems:</p>
<table>
<thead>
<tr>
<th>Cause</th>
<th>Description</th>
<th>Impact</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Manual configuration changes</strong></td>
<td>Direct modifications to production systems without updating architecture definitions</td>
<td>Discrepancies between documented and actual system state</td>
</tr>
<tr>
<td><strong>Emergency patches</strong></td>
<td>Urgent fixes applied under pressure without following standard processes</td>
<td>Bypassed architectural guardrails and undocumented changes</td>
</tr>
<tr>
<td><strong>Knowledge loss</strong></td>
<td>Team member turnover and inadequate documentation transfer</td>
<td>Loss of architectural context and rationale for design decisions</td>
</tr>
<tr>
<td><strong>Tool and process fragmentation</strong></td>
<td>Multiple teams using different tools and approaches</td>
<td>Inconsistent implementations across the system landscape</td>
</tr>
<tr>
<td><strong>Lack of validation</strong></td>
<td>Absence of automated checks comparing desired versus actual state</td>
<td>Undetected deviations accumulating over extended periods</td>
</tr>
</tbody>
</table>
<h4 id="consequences-of-architectural-drift">Consequences of architectural drift</h4>
<p>Uncontrolled architectural drift creates significant technical and business risks:</p>
<ul>
<li><strong>Increased complexity</strong>: Systems become harder to understand, maintain, and modify as actual implementation diverges from documentation</li>
<li><strong>Security vulnerabilities</strong>: Undocumented changes may introduce security weaknesses that bypass established controls</li>
<li><strong>Compliance violations</strong>: Drift can cause systems to fall out of compliance with regulatory requirements and industry standards</li>
<li><strong>Reduced reliability</strong>: Inconsistent configurations and undocumented dependencies increase the likelihood of failures and outages</li>
<li><strong>Higher operational costs</strong>: Time spent troubleshooting, reconciling, and recovering from drift-related incidents escalates operational expenses</li>
<li><strong>Impeded innovation</strong>: Technical debt from drift makes it difficult to implement new features or modernise systems</li>
</ul>
<h4 id="how-architecture-as-code-prevents-drift">How Architecture as Code prevents drift</h4>
<p>Architecture as Code addresses architectural drift through several mechanisms:</p>
<p><strong>Declarative definitions</strong>: Systems are defined in code that explicitly states the desired architecture, making deviations immediately visible through comparison tools and automated validation.</p>
<p><strong>Version control</strong>: All architectural changes are tracked in Git or similar systems, creating an immutable audit trail that documents every modification and the rationale behind it.</p>
<p><strong>Automated enforcement</strong>: Policy-as-code frameworks and continuous validation pipelines prevent unauthorised changes from being deployed and detect drift in running systems.</p>
<p><strong>Immutable infrastructure</strong>: Rather than modifying running systems, new versions are created and deployed, eliminating the possibility of undocumented manual changes.</p>
<p><strong>Continuous reconciliation</strong>: Automated tools regularly compare the actual system state against the codified architecture, identifying and reporting any discrepancies for immediate remediation.</p>
<p><strong>Infrastructure state management</strong>: Tools such as Terraform, Pulumi, and CloudFormation maintain explicit state representations, enabling automatic detection when actual infrastructure diverges from the declared configuration.</p>
<h4 id="drift-detection-and-remediation">Drift detection and remediation</h4>
<p>Modern Architecture as Code toolchains provide built-in drift detection capabilities:</p>
<pre><code class="language-bash"># Terraform detects configuration drift
terraform plan
# Output shows resources that have been modified outside Terraform

# CloudFormation drift detection
aws cloudformation detect-stack-drift --stack-name production-stack
aws cloudformation describe-stack-drift-detection-status

# Azure Resource Manager drift detection
az deployment group what-if --resource-group production-rg \
  --template-file infrastructure.bicep
</code></pre>
<p>When drift is detected, teams can choose to either:
1. <strong>Remediate automatically</strong>: Reapply the codified architecture to restore the system to its intended state
2. <strong>Update the code</strong>: If the drift represents an intentional change, update the architecture definition to reflect the new desired state
3. <strong>Investigate and resolve</strong>: Determine the root cause of drift, fix the underlying process gap, and prevent recurrence</p>
<p>By treating architecture as code and automating drift detection and remediation, organisations maintain architectural integrity throughout the entire system lifecycle, ensuring that reality consistently matches design intent.</p>
<h2 id="testability-at-the-architecture-level">Testability at the architecture level</h2>
<p>Architecture as Code enables testing of the entire system architecture, not only individual components. This includes validating architectural patterns, adherence to design principles, and verification of end-to-end flows.</p>
<p>Architecture tests confirm design decisions, assess system complexity, and ensure the complete architecture behaves as intended.</p>
<h2 id="documentation-as-code">Documentation as Code</h2>
<p>Documentation as Code (DaC) treats documentation as an integrated part of the codebase rather than a separate artefact. Documentation is stored alongside the code, version-controlled with the same tools, and subject to the same quality assurance processes as application code.</p>
<h3 id="benefits-of-documentation-as-code">Benefits of Documentation as Code</h3>
<table>
<thead>
<tr>
<th>Benefit</th>
<th>Description</th>
<th>Key Advantages</th>
</tr>
</thead>
<tbody>
<tr>
<td>Version control and history</td>
<td>Storing documentation in Git or other version control systems</td>
<td>Automatic traceability of changes, ability to restore previous versions, complete history of documentation evolution</td>
</tr>
<tr>
<td>Collaboration and review</td>
<td>Pull requests and merge processes for documentation updates</td>
<td>Improved quality, reduced risk of inaccurate or outdated information, peer review before publication</td>
</tr>
<tr>
<td>CI/CD integration</td>
<td>Automated pipelines for documentation generation and deployment</td>
<td>Removes manual steps, ensures documentation remains current, automatic validation on changes</td>
</tr>
</tbody>
</table>
<h3 id="practical-implementation">Practical implementation</h3>
<pre><code class="language-yaml"># .github/workflows/docs.yml
name: Documentation Build and Deploy
on:
  push:
    paths: ['docs/**', 'README.md']
  pull_request:
    paths: ['docs/**']

jobs:
  build-docs:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install dependencies
        run: npm install

      - name: Generate documentation
        run: |
          npm run docs:build
          npm run docs:lint

      - name: Deploy to GitHub Pages
        if: github.ref == 'refs/heads/main'
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./docs/dist
</code></pre>
<p>Modern tools such as GitBook, Gitiles, and MkDocs enable automatic generation of web documentation from Markdown files stored alongside the code.</p>
<p>The Architecture as Code repository demonstrates this principle by coupling
<a href="../documentation_workflow/"><code>docs/documentation_workflow.md</code></a> with automated tests
that enforce heading and link conventions during every pull request. Contributors
cannot merge narrative or architectural updates until the shared Git-based workflow
and validation pipeline succeed, ensuring documentation remains authoritative without
falling back on disconnected wikis or manual approvals.</p>
<h2 id="requirements-as-code">Requirements as Code</h2>
<p>Requirements as Code (RaC) transforms traditional requirements specifications from textual documents into machine-readable code that can be executed, validated, and automated. This paradigm shift enables continuous verification that the system meets its requirements throughout the entire development lifecycle.</p>
<h3 id="automation-and-traceability">Automation and traceability</h3>
<table>
<thead>
<tr>
<th>Capability</th>
<th>Description</th>
<th>Business Impact</th>
</tr>
</thead>
<tbody>
<tr>
<td>Automated validation</td>
<td>Requirements expressed as code run automatically against the system to verify compliance</td>
<td>Removes manual testing, ensures consistent validation, reduces human error</td>
</tr>
<tr>
<td>Direct link between requirements and code</td>
<td>Each system component can be traced back to specific requirements</td>
<td>Complete traceability from business needs to technical implementation, improved audit capability</td>
</tr>
<tr>
<td>Continuous compliance</td>
<td>System changes are automatically validated against all defined requirements</td>
<td>Prevents regressions, ensures ongoing compliance, reduces regulatory risk</td>
</tr>
</tbody>
</table>
<h3 id="practical-example-with-open-policy-agent-opa">Practical example with Open Policy Agent (OPA)</h3>
<p>The following requirements set reflects a pan-European perspective. Metadata values
use EU-wide terminology, and individual controls reference guidance from the
European Data Protection Board (EDPB) alongside ENISA security baselines. This
alignment keeps Architecture as Code artefacts consistent with the regulatory
language used across the European Union rather than country-specific phrasing.</p>
<pre><code class="language-yaml"># requirements/security-requirements.yaml
apiVersion: policy/v1
kind: RequirementSet
metadata:
  name: eu-security-requirements
  version: &quot;1.2&quot;
spec:
  requirements:
    - id: SEC-001
      type: security
      description: &quot;All S3 buckets must have encryption enabled&quot;
      priority: critical
      compliance: [&quot;GDPR&quot;, &quot;ISO27001&quot;]
      policy: |
        package security.s3_encryption

        deny[msg] {
          input.resource_type == &quot;aws_s3_bucket&quot;
          not input.server_side_encryption_configuration
          msg := &quot;S3 bucket must have server-side encryption&quot;
        }

    - id: GDPR-001
      type: compliance
      description: &quot;Personal data must be stored within the EU/EEA&quot;
      priority: critical
      compliance: [&quot;GDPR&quot;]
      policy: |
        package compliance.data_residency

        deny[msg] {
          input.resource_type == &quot;aws_rds_instance&quot;
          not contains(input.availability_zone, &quot;eu-&quot;)
          msg := &quot;RDS instance must be located in an EU region&quot;
        }
</code></pre>
<h3 id="validation-and-test-automation">Validation and test automation</h3>
<p>Requirements as Code integrates naturally with test automation because requirements become executable specifications:</p>
<pre><code class="language-python"># test/requirements_validation.py
import yaml
import opa

EU_VALIDATION_AUTHORITIES = {
    &quot;GDPR&quot;: {
        &quot;authority&quot;: &quot;European Data Protection Board&quot;,
        &quot;reference&quot;: &quot;EDPB Guidelines 07/2020&quot;,
    },
    &quot;ISO27001&quot;: {
        &quot;authority&quot;: &quot;European Union Agency for Cybersecurity (ENISA)&quot;,
        &quot;reference&quot;: &quot;ENISA Information Security Baseline, 2024&quot;,
    },
}

class RequirementsValidator:
    def __init__(self, requirements_file: str, system_config: dict):
        with open(requirements_file, 'r') as f:
            self.requirements = yaml.safe_load(f)
        self.system_config = system_config

    def validate_requirement(self, req_id: str, system_config: dict):
        requirement = self.find_requirement(req_id)
        policy_result = opa.evaluate(
            requirement['policy'],
            system_config
        )
        return {
            'requirement_id': req_id,
            'status': 'passed' if not policy_result else 'failed',
            'violations': policy_result,
            'validation_reference': EU_VALIDATION_AUTHORITIES.get(
                requirement.get('compliance', [None])[0]
            ),
        }

    def validate_all_requirements(self) -&gt; dict:
        results = []
        for req in self.requirements['spec']['requirements']:
            result = self.validate_requirement(req['id'], self.system_config)
            results.append(result)

        return {
            'total_requirements': len(self.requirements['spec']['requirements']),
            'passed': len([r for r in results if r['status'] == 'passed']),
            'failed': len([r for r in results if r['status'] == 'failed']),
            'details': results
        }
</code></pre>
<p>Global organisations benefit from Requirements as Code by automatically validating regulatory compliance, financial controls, and statutory obligations that must be met continuously.</p>
<p>In this European-centric example the validator enriches every result with the
appropriate supervisory authority. Teams can therefore map each automated
decision directly to EDPB guidance or ENISA security baselines, ensuring the
language reported to auditors mirrors the terminology mandated across the EU.</p>
<h3 id="functional-vs-non-functional-requirements-as-code">Functional vs Non-Functional Requirements as Code</h3>
<p>Understanding the distinction between functional and non-functional requirements is fundamental to implementing effective Requirements as Code. This distinction affects how requirements are verified and what methods are used to ensure system compliance.</p>
<p><strong>Functional Requirements</strong> define what the system should do – the specific behaviours, features, and capabilities that the system must provide. Examples include "users must be able to authenticate using multi-factor authentication" or "the system must encrypt data at rest". Functional requirements describe business logic, user interactions, data processing, and specific system functions.</p>
<p><strong>Non-Functional Requirements</strong> (NFRs) define how the system should perform – the quality attributes, constraints, and operational characteristics. Examples include performance thresholds ("response time must be under 200ms"), scalability requirements ("system must handle 10,000 concurrent users"), availability targets ("99.9% uptime"), and security standards ("must comply with ISO 27001").</p>
<h4 id="the-v-model-and-requirements-verification">The V-Model and Requirements Verification</h4>
<p><img alt="V-Model for Requirements Verification" src="../images/diagram_02_v_model.png" /></p>
<p><em>Figure 2.2: V-Model illustrating the relationship between requirements specification and verification methods</em></p>
<p>The V-Model illustrates a critical distinction in how different requirement types are verified in Architecture as Code:</p>
<p><strong>Non-Functional Requirements → Testing</strong>: NFRs are inherently testable through automated metrics and measurements. Performance can be measured through load tests, security can be verified through automated scanning, and availability can be monitored through uptime metrics. These requirements translate directly into executable tests that provide objective pass/fail results.</p>
<p><strong>Functional Requirements → Validation</strong>: Functional requirements require validation to confirm they meet business intent and user needs. While individual functions can be tested (unit tests, integration tests), validating that the system solves the correct business problem requires human judgment, user acceptance testing, and stakeholder confirmation.</p>
<p>This distinction is reflected in the V-Model's right side:
- <strong>Unit Testing</strong> verifies low-level NFRs (code quality, performance of individual components)
- <strong>Integration Testing</strong> verifies system-level NFRs (component interactions, data flows)
- <strong>System Testing</strong> verifies complete NFRs (end-to-end performance, security, scalability)
- <strong>Acceptance Testing</strong> validates functional requirements against business needs
- <strong>Operational Validation</strong> confirms the system delivers business value in production</p>
<h4 id="practical-implementation-patterns">Practical Implementation Patterns</h4>
<p>When implementing Requirements as Code, the testing versus validation distinction manifests in different automation patterns:</p>
<p><strong>Non-Functional Requirements as Automated Tests:</strong></p>
<pre><code class="language-yaml"># requirements/performance-nfr.yaml
apiVersion: policy/v1
kind: NonFunctionalRequirement
metadata:
  name: api-performance-requirements
  category: performance
spec:
  requirement:
    id: NFR-PERF-001
    description: &quot;API response time under load&quot;
    metric: response_time_p95
    threshold: 200
    unit: milliseconds
  test:
    type: load_test
    tool: k6
    script: |
      import http from 'k6/http';
      import { check } from 'k6';

      export let options = {
        stages: [
          { duration: '2m', target: 100 },
          { duration: '5m', target: 100 },
          { duration: '2m', target: 0 },
        ],
        thresholds: {
          'http_req_duration{type:api}': ['p(95)&lt;200'],
        },
      };

      export default function() {
        let response = http.get('https://api.example.com/health');
        check(response, {
          'status is 200': (r) =&gt; r.status === 200,
          'response time OK': (r) =&gt; r.timings.duration &lt; 200,
        });
      }
</code></pre>
<p><strong>Functional Requirements as Validation Specifications:</strong></p>
<pre><code class="language-yaml"># requirements/authentication-fr.yaml
apiVersion: policy/v1
kind: FunctionalRequirement
metadata:
  name: mfa-authentication
  category: security
spec:
  requirement:
    id: FR-AUTH-001
    description: &quot;Users must authenticate with multi-factor authentication&quot;
    acceptance_criteria:
      - &quot;User provides valid username and password&quot;
      - &quot;System prompts for second factor (TOTP or SMS)&quot;
      - &quot;User provides valid second factor&quot;
      - &quot;System grants access only after both factors verified&quot;
      - &quot;System logs all authentication attempts&quot;
  validation:
    type: acceptance_test
    stakeholders:
      - security_team
      - product_owner
      - end_users
    validation_method: user_acceptance_testing
    success_criteria:
      - &quot;Security team confirms implementation meets security policy&quot;
      - &quot;Product owner confirms user experience is acceptable&quot;
      - &quot;End users successfully complete authentication flow&quot;
      - &quot;Penetration testing confirms no bypass vulnerabilities&quot;
  implementation_tests:
    # These test the implementation, not the requirement itself
    - type: integration_test
      description: &quot;Verify TOTP generation and validation&quot;
    - type: integration_test
      description: &quot;Verify SMS delivery and code validation&quot;
    - type: security_test
      description: &quot;Verify no authentication bypass exists&quot;
</code></pre>
<h4 id="testability-characteristics">Testability Characteristics</h4>
<p>The table below summarises key differences in how functional and non-functional requirements are verified as code:</p>
<table>
<thead>
<tr>
<th>Characteristic</th>
<th>Non-Functional Requirements</th>
<th>Functional Requirements</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Verification Method</strong></td>
<td>Automated testing with objective metrics</td>
<td>Validation through acceptance criteria and stakeholder confirmation</td>
</tr>
<tr>
<td><strong>Measurability</strong></td>
<td>Directly measurable (milliseconds, percentages, counts)</td>
<td>Requires human judgment of business value and correctness</td>
</tr>
<tr>
<td><strong>Automation Level</strong></td>
<td>Fully automated continuous testing</td>
<td>Semi-automated: tests verify implementation, humans validate correctness</td>
</tr>
<tr>
<td><strong>Pass/Fail Criteria</strong></td>
<td>Quantitative thresholds (&lt; 200ms, &gt; 99.9% uptime)</td>
<td>Qualitative acceptance (meets business need, solves user problem)</td>
</tr>
<tr>
<td><strong>Typical Tools</strong></td>
<td>Load testing (k6, JMeter), security scanning (OWASP ZAP), monitoring (Prometheus)</td>
<td>User acceptance testing, stakeholder reviews, business validation</td>
</tr>
<tr>
<td><strong>Continuous Verification</strong></td>
<td>Every deployment through automated pipelines</td>
<td>Major releases, feature delivery, stakeholder review cycles</td>
</tr>
<tr>
<td><strong>Example Requirements</strong></td>
<td>Performance, scalability, security controls, availability, resource utilisation</td>
<td>Business workflows, user interactions, data processing logic, feature behaviour</td>
</tr>
</tbody>
</table>
<h4 id="implications-for-architecture-as-code">Implications for Architecture as Code</h4>
<p>This distinction has profound implications for how Architecture as Code is implemented:</p>
<ol>
<li>
<p><strong>NFR Testing in CI/CD</strong>: Non-functional requirements integrate seamlessly into continuous deployment pipelines. Every infrastructure change can be automatically tested for performance impact, security compliance, and operational characteristics.</p>
</li>
<li>
<p><strong>FR Validation Gates</strong>: Functional requirements require explicit validation gates where stakeholders confirm business value. These gates cannot be fully automated but can be facilitated through Requirements as Code specifications that document acceptance criteria and track validation status.</p>
</li>
<li>
<p><strong>Traceability Requirements</strong>: Both requirement types need traceability to implementation, but NFRs trace to automated test results while FRs trace to validation decisions and stakeholder approvals.</p>
</li>
<li>
<p><strong>Policy Enforcement</strong>: NFRs can be enforced through policy-as-code frameworks (like OPA) that automatically block deployments failing to meet thresholds. FR enforcement requires human decision-making about whether implementation satisfies business intent.</p>
</li>
<li>
<p><strong>Living Documentation</strong>: Requirements as Code creates living documentation where NFR compliance status is always current (reflected by latest test results) while FR validation status requires explicit updates as stakeholders confirm business value delivery.</p>
</li>
</ol>
<p>This dual approach – automated testing for NFRs and structured validation for FRs – enables organisations to achieve both technical excellence and business value alignment through Architecture as Code practices.</p>
<p>Sources:
- Red Hat. "Architecture as Code Principles and Best Practices." Red Hat Developer.
- Martin, R. "Clean Architecture: A Craftsman's Guide to Software Structure." Prentice Hall, 2017.
- ThoughtWorks. "Architecture as Code: The Next Evolution." Technology Radar, 2024.
- GitLab. "Documentation as Code: Best Practices and Implementation." GitLab Documentation, 2024.
- GitHub Docs. "About protected branches." GitHub Documentation, 2024.
- Open Policy Agent. "Policy as Code: Expressing Requirements as Code." CNCF OPA Project, 2024.
- Atlassian. "Documentation as Code: Treating Docs as a First-Class Citizen." Atlassian Developer, 2023.
- NIST. "Requirements Engineering for Secure Systems." NIST Special Publication 800-160, 2023.
- Forsberg, K., Mooz, H. "The Relationship of System Engineering to the Project Cycle." Engineering Management Journal, 1991.
- IEEE. "IEEE Standard for Software Verification and Validation." IEEE Std 1012-2016, 2017.
- Chung, L., et al. "Non-Functional Requirements in Software Engineering." Springer, 2000.</p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../01_introduction/" class="btn btn-neutral float-left" title="Introduction to Architecture as Code"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../03_version_control/" class="btn btn-neutral float-right" title="Version Control and Code Structure">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/geonitab/architecture_as_code" class="fa fa-code-fork" style="color: #fcfcfc"> architecture_as_code</a>
        </span>
    
    
      <span><a href="../01_introduction/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../03_version_control/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../javascripts/mermaid-init.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
